<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PosalPro MVP2 - Improved Real-World Performance Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .content {
            padding: 30px;
        }
        
        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #e1e5e9;
            border-radius: 8px;
            background: #f8f9fa;
        }
        
        .test-section h3 {
            margin-top: 0;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #95a5a6;
            display: inline-block;
        }
        
        .status-indicator.running {
            background: #f39c12;
            animation: pulse 1.5s infinite;
        }
        
        .status-indicator.success {
            background: #27ae60;
        }
        
        .status-indicator.error {
            background: #e74c3c;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .controls {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .progress-container {
            background: #ecf0f1;
            border-radius: 10px;
            height: 8px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #ecf0f1;
        }
        
        .metric:last-child {
            border-bottom: none;
        }
        
        .metric-value {
            font-weight: 600;
            font-size: 1.1em;
        }
        
        .metric-value.good {
            color: #27ae60;
        }
        
        .metric-value.warning {
            color: #f39c12;
        }
        
        .metric-value.error {
            color: #e74c3c;
        }
        
        .log {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 14px;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 20px;
        }
        
        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-radius: 3px;
        }
        
        .log-entry.info {
            color: #3498db;
        }
        
        .log-entry.success {
            color: #2ecc71;
        }
        
        .log-entry.warning {
            color: #f39c12;
        }
        
        .log-entry.error {
            color: #e74c3c;
        }
        
        .score-display {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px;
            margin: 20px 0;
        }
        
        .score-number {
            font-size: 3em;
            font-weight: 300;
            margin: 0;
        }
        
        .score-label {
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        .results {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ PosalPro MVP2 Performance Test</h1>
            <p>Real-World Frontend Performance Analysis</p>
        </div>
        
        <div class="content">
            <div class="controls">
                <button id="startTest" class="btn">üèÉ‚Äç‚ôÇÔ∏è Start Performance Test</button>
                <button id="stopTest" class="btn" disabled>‚èπÔ∏è Stop Test</button>
                <button id="clearResults" class="btn">üóëÔ∏è Clear Results</button>
            </div>
            
            <div class="test-section">
                <h3>
                    <span class="status-indicator" id="renderStatus"></span>
                    DOM Rendering Performance
                </h3>
                <div id="renderResults">Testing DOM manipulation and rendering speed...</div>
                <div class="progress-container">
                    <div class="progress-bar" id="renderProgress"></div>
                </div>
            </div>
            
            <div class="test-section">
                <h3>
                    <span class="status-indicator" id="memoryStatus"></span>
                    Memory & Resource Usage
                </h3>
                <div id="memoryResults">Analyzing memory consumption and leaks...</div>
                <div class="progress-container">
                    <div class="progress-bar" id="memoryProgress"></div>
                </div>
            </div>
            
            <div class="test-section">
                <h3>
                    <span class="status-indicator" id="serviceWorkerStatus"></span>
                    Service Worker Performance
                </h3>
                <div id="serviceWorkerResults">Testing caching and offline capabilities...</div>
                <div class="progress-container">
                    <div class="progress-bar" id="serviceWorkerProgress"></div>
                </div>
            </div>
            
            <div class="test-section">
                <h3>
                    <span class="status-indicator" id="analyticsStatus"></span>
                    Analytics Performance
                </h3>
                <div id="analyticsResults">Testing event processing and batching...</div>
                <div class="progress-container">
                    <div class="progress-bar" id="analyticsProgress"></div>
                </div>
            </div>
            
            <div class="score-display" id="scoreDisplay" style="display: none;">
                <div class="score-number" id="scoreNumber">--</div>
                <div class="score-label">Performance Score</div>
            </div>
            
            <div class="results" id="detailedResults" style="display: none;">
                <h3>üìä Detailed Results</h3>
                <div id="metricsContainer"></div>
            </div>
            
            <div class="log" id="logContainer">
                <div class="log-entry info">üîÑ Ready to start performance testing...</div>
            </div>
        </div>
    </div>

    <script>
        class ImprovedPerformanceTest {
            constructor() {
                this.isRunning = false;
                this.results = {
                    rendering: {},
                    memory: {},
                    serviceWorker: {},
                    analytics: {},
                    score: 0
                };
                this.initializeEventListeners();
            }
            
            initializeEventListeners() {
                document.getElementById('startTest').addEventListener('click', () => this.startTest());
                document.getElementById('stopTest').addEventListener('click', () => this.stopTest());
                document.getElementById('clearResults').addEventListener('click', () => this.clearResults());
            }
            
            log(message, type = 'info') {
                const logContainer = document.getElementById('logContainer');
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry ${type}`;
                logEntry.textContent = `[${timestamp}] ${message}`;
                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;
                console.log(`[${timestamp}] ${message}`);
            }
            
            updateStatus(testType, status) {
                const statusElement = document.getElementById(`${testType}Status`);
                statusElement.className = `status-indicator ${status}`;
            }
            
            updateProgress(testType, progress) {
                const progressElement = document.getElementById(`${testType}Progress`);
                progressElement.style.width = `${progress}%`;
            }
            
            async startTest() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                document.getElementById('startTest').disabled = true;
                document.getElementById('stopTest').disabled = false;
                
                this.log('üöÄ Starting comprehensive performance test...', 'info');
                
                try {
                    await this.testDOMRendering();
                    if (!this.isRunning) return;
                    
                    await this.testMemoryUsage();
                    if (!this.isRunning) return;
                    
                    await this.testServiceWorker();
                    if (!this.isRunning) return;
                    
                    await this.testAnalyticsPerformance();
                    if (!this.isRunning) return;
                    
                    this.calculateScore();
                    this.displayResults();
                    this.log('‚úÖ Performance test completed successfully!', 'success');
                    
                } catch (error) {
                    this.log(`‚ùå Test failed: ${error.message}`, 'error');
                } finally {
                    this.isRunning = false;
                    document.getElementById('startTest').disabled = false;
                    document.getElementById('stopTest').disabled = true;
                }
            }
            
            async testDOMRendering() {
                this.log('üé® Testing DOM rendering performance...', 'info');
                this.updateStatus('render', 'running');
                
                const startTime = performance.now();
                
                // Test 1: Large DOM manipulation
                const testContainer = document.createElement('div');
                testContainer.style.visibility = 'hidden';
                document.body.appendChild(testContainer);
                
                const domStartTime = performance.now();
                for (let i = 0; i < 1000; i++) {
                    const element = document.createElement('div');
                    element.textContent = `Test element ${i}`;
                    element.className = 'test-element';
                    testContainer.appendChild(element);
                }
                const domManipulationTime = performance.now() - domStartTime;
                this.updateProgress('render', 25);
                
                // Test 2: CSS styling performance
                const styleStartTime = performance.now();
                const elements = testContainer.querySelectorAll('.test-element');
                elements.forEach((el, index) => {
                    el.style.backgroundColor = index % 2 === 0 ? '#f0f0f0' : '#ffffff';
                    el.style.padding = '10px';
                    el.style.margin = '2px';
                });
                const stylingTime = performance.now() - styleStartTime;
                this.updateProgress('render', 50);
                
                // Test 3: Layout thrashing test
                const layoutStartTime = performance.now();
                elements.forEach((el, index) => {
                    if (index < 100) {
                        el.offsetHeight; // Force layout
                        el.style.height = '20px';
                    }
                });
                const layoutTime = performance.now() - layoutStartTime;
                this.updateProgress('render', 75);
                
                // Test 4: Event handling performance
                const eventStartTime = performance.now();
                let eventCount = 0;
                const eventHandler = () => eventCount++;
                
                for (let i = 0; i < 100; i++) {
                    const element = elements[i];
                    if (element) {
                        element.addEventListener('click', eventHandler);
                        element.click();
                        element.removeEventListener('click', eventHandler);
                    }
                }
                const eventTime = performance.now() - eventStartTime;
                
                // Cleanup
                document.body.removeChild(testContainer);
                
                const totalTime = performance.now() - startTime;
                this.updateProgress('render', 100);
                
                this.results.rendering = {
                    domManipulation: Math.round(domManipulationTime),
                    styling: Math.round(stylingTime),
                    layout: Math.round(layoutTime),
                    events: Math.round(eventTime),
                    total: Math.round(totalTime),
                    success: true
                };
                
                this.updateStatus('render', 'success');
                this.log(`‚úÖ DOM Rendering: ${Math.round(totalTime)}ms (DOM: ${Math.round(domManipulationTime)}ms, Style: ${Math.round(stylingTime)}ms)`, 'success');
            }
            
            async testMemoryUsage() {
                this.log('üíæ Testing memory usage and leaks...', 'info');
                this.updateStatus('memory', 'running');
                
                const initialMemory = this.getMemoryUsage();
                this.updateProgress('memory', 25);
                
                // Test 1: Memory allocation stress test
                const memoryTestArrays = [];
                for (let i = 0; i < 100; i++) {
                    memoryTestArrays.push(new Array(1000).fill(`test-data-${i}`));
                }
                
                const afterAllocationMemory = this.getMemoryUsage();
                this.updateProgress('memory', 50);
                
                // Test 2: Cleanup and garbage collection
                memoryTestArrays.length = 0;
                
                // Force garbage collection if available
                if (window.gc) {
                    window.gc();
                }
                
                // Wait for potential GC
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const afterCleanupMemory = this.getMemoryUsage();
                this.updateProgress('memory', 75);
                
                // Test 3: Performance memory API
                const performanceMemory = performance.memory ? {
                    used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
                    total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
                    limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
                } : null;
                
                this.updateProgress('memory', 100);
                
                this.results.memory = {
                    initial: initialMemory,
                    afterAllocation: afterAllocationMemory,
                    afterCleanup: afterCleanupMemory,
                    performanceMemory,
                    memoryLeak: afterCleanupMemory - initialMemory,
                    success: true
                };
                
                this.updateStatus('memory', 'success');
                this.log(`‚úÖ Memory: ${afterCleanupMemory.toFixed(1)}MB used, ${(afterCleanupMemory - initialMemory).toFixed(1)}MB potential leak`, 'success');
            }
            
            async testServiceWorker() {
                this.log('‚öôÔ∏è Testing service worker performance...', 'info');
                this.updateStatus('serviceWorker', 'running');
                
                const startTime = performance.now();
                
                // Test 1: Service worker registration status
                const swRegistration = await this.checkServiceWorkerRegistration();
                this.updateProgress('serviceWorker', 25);
                
                // Test 2: Cache API performance
                const cachePerformance = await this.testCacheAPI();
                this.updateProgress('serviceWorker', 50);
                
                // Test 3: Network vs Cache speed
                const networkCacheComparison = await this.testNetworkVsCache();
                this.updateProgress('serviceWorker', 75);
                
                // Test 4: Background sync capability
                const backgroundSyncSupport = 'serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype;
                this.updateProgress('serviceWorker', 100);
                
                const totalTime = performance.now() - startTime;
                
                this.results.serviceWorker = {
                    registration: swRegistration,
                    cachePerformance,
                    networkCacheComparison,
                    backgroundSyncSupport,
                    totalTime: Math.round(totalTime),
                    success: true
                };
                
                this.updateStatus('serviceWorker', swRegistration.registered ? 'success' : 'warning');
                this.log(`‚úÖ Service Worker: ${swRegistration.registered ? 'Active' : 'Not registered'}, Cache: ${cachePerformance.supported ? 'Supported' : 'Not supported'}`, 'success');
            }
            
            async testAnalyticsPerformance() {
                this.log('üìà Testing analytics performance...', 'info');
                this.updateStatus('analytics', 'running');
                
                const startTime = performance.now();
                
                // Test 1: Event processing speed
                const eventProcessingStart = performance.now();
                const events = [];
                for (let i = 0; i < 1000; i++) {
                    events.push({
                        type: 'test_event',
                        timestamp: Date.now(),
                        data: { index: i, value: Math.random() }
                    });
                }
                const eventProcessingTime = performance.now() - eventProcessingStart;
                this.updateProgress('analytics', 25);
                
                // Test 2: Event batching simulation
                const batchingStart = performance.now();
                const batches = [];
                for (let i = 0; i < events.length; i += 10) {
                    batches.push(events.slice(i, i + 10));
                }
                const batchingTime = performance.now() - batchingStart;
                this.updateProgress('analytics', 50);
                
                // Test 3: Local storage performance
                const storageStart = performance.now();
                const testData = JSON.stringify(events.slice(0, 100));
                try {
                    localStorage.setItem('perf_test_analytics', testData);
                    const retrieved = localStorage.getItem('perf_test_analytics');
                    localStorage.removeItem('perf_test_analytics');
                    const storageWorking = retrieved === testData;
                    var storageTime = performance.now() - storageStart;
                } catch (error) {
                    var storageTime = -1;
                    var storageWorking = false;
                }
                this.updateProgress('analytics', 75);
                
                // Test 4: Performance observer simulation
                const observerStart = performance.now();
                let performanceEntries = [];
                if ('PerformanceObserver' in window) {
                    performanceEntries = performance.getEntriesByType('navigation');
                }
                const observerTime = performance.now() - observerStart;
                this.updateProgress('analytics', 100);
                
                const totalTime = performance.now() - startTime;
                
                this.results.analytics = {
                    eventProcessing: Math.round(eventProcessingTime),
                    batching: Math.round(batchingTime),
                    storage: Math.round(storageTime),
                    storageWorking,
                    observer: Math.round(observerTime),
                    performanceEntriesCount: performanceEntries.length,
                    totalTime: Math.round(totalTime),
                    success: true
                };
                
                this.updateStatus('analytics', 'success');
                this.log(`‚úÖ Analytics: ${Math.round(totalTime)}ms processing, ${events.length} events, ${batches.length} batches`, 'success');
            }
            
            async checkServiceWorkerRegistration() {
                if (!('serviceWorker' in navigator)) {
                    return { registered: false, reason: 'Not supported' };
                }
                
                try {
                    const registration = await navigator.serviceWorker.getRegistration();
                    return {
                        registered: !!registration,
                        active: !!(registration && registration.active),
                        scope: registration ? registration.scope : null
                    };
                } catch (error) {
                    return { registered: false, reason: error.message };
                }
            }
            
            async testCacheAPI() {
                if (!('caches' in window)) {
                    return { supported: false, reason: 'Cache API not supported' };
                }
                
                try {
                    const cacheName = 'perf-test-cache';
                    const cache = await caches.open(cacheName);
                    
                    const testUrl = '/test-cache-performance';
                    const testResponse = new Response('test data', {
                        headers: { 'Content-Type': 'text/plain' }
                    });
                    
                    const putStart = performance.now();
                    await cache.put(testUrl, testResponse.clone());
                    const putTime = performance.now() - putStart;
                    
                    const getStart = performance.now();
                    const cachedResponse = await cache.match(testUrl);
                    const getTime = performance.now() - getStart;
                    
                    await caches.delete(cacheName);
                    
                    return {
                        supported: true,
                        putTime: Math.round(putTime),
                        getTime: Math.round(getTime),
                        working: !!cachedResponse
                    };
                } catch (error) {
                    return { supported: false, reason: error.message };
                }
            }
            
            async testNetworkVsCache() {
                // Simulate network vs cache comparison
                const networkStart = performance.now();
                await new Promise(resolve => setTimeout(resolve, 50)); // Simulate network delay
                const networkTime = performance.now() - networkStart;
                
                const cacheStart = performance.now();
                await new Promise(resolve => setTimeout(resolve, 5)); // Simulate cache access
                const cacheTime = performance.now() - cacheStart;
                
                return {
                    networkTime: Math.round(networkTime),
                    cacheTime: Math.round(cacheTime),
                    improvement: Math.round(((networkTime - cacheTime) / networkTime) * 100)
                };
            }
            
            getMemoryUsage() {
                if (performance.memory) {
                    return performance.memory.usedJSHeapSize / 1024 / 1024;
                }
                return 0;
            }
            
            calculateScore() {
                let score = 100;
                
                // DOM rendering score (25 points)
                if (this.results.rendering.success) {
                    const totalRenderTime = this.results.rendering.total;
                    if (totalRenderTime > 100) score -= 10;
                    if (totalRenderTime > 200) score -= 10;
                    if (totalRenderTime > 500) score -= 5;
                } else {
                    score -= 25;
                }
                
                // Memory score (25 points)
                if (this.results.memory.success) {
                    const memoryLeak = this.results.memory.memoryLeak;
                    if (memoryLeak > 5) score -= 10;
                    if (memoryLeak > 10) score -= 10;
                    if (memoryLeak > 20) score -= 5;
                } else {
                    score -= 25;
                }
                
                // Service worker score (25 points)
                if (this.results.serviceWorker.success) {
                    if (!this.results.serviceWorker.registration.registered) score -= 15;
                    if (!this.results.serviceWorker.cachePerformance.supported) score -= 10;
                } else {
                    score -= 25;
                }
                
                // Analytics score (25 points)
                if (this.results.analytics.success) {
                    const analyticsTime = this.results.analytics.totalTime;
                    if (analyticsTime > 50) score -= 10;
                    if (analyticsTime > 100) score -= 10;
                    if (!this.results.analytics.storageWorking) score -= 5;
                } else {
                    score -= 25;
                }
                
                this.results.score = Math.max(0, score);
            }
            
            displayResults() {
                const scoreDisplay = document.getElementById('scoreDisplay');
                const scoreNumber = document.getElementById('scoreNumber');
                const detailedResults = document.getElementById('detailedResults');
                const metricsContainer = document.getElementById('metricsContainer');
                
                scoreNumber.textContent = this.results.score;
                scoreDisplay.style.display = 'block';
                
                // Display detailed metrics
                metricsContainer.innerHTML = '';
                
                const metrics = [
                    { label: 'DOM Rendering Time', value: this.results.rendering.total || 'N/A', unit: 'ms', threshold: 100 },
                    { label: 'Memory Usage', value: this.results.memory.afterCleanup || 'N/A', unit: 'MB', threshold: 50 },
                    { label: 'Memory Leak', value: this.results.memory.memoryLeak || 'N/A', unit: 'MB', threshold: 5 },
                    { label: 'Service Worker', value: this.results.serviceWorker.registration.registered ? 'Active' : 'Inactive', unit: '', threshold: 0 },
                    { label: 'Cache Performance', value: this.results.serviceWorker.cachePerformance.supported ? 'Supported' : 'Not Supported', unit: '', threshold: 0 },
                    { label: 'Analytics Processing', value: this.results.analytics.totalTime || 'N/A', unit: 'ms', threshold: 50 }
                ];
                
                metrics.forEach(metric => {
                    const metricDiv = document.createElement('div');
                    metricDiv.className = 'metric';
                    
                    let valueClass = '';
                    if (typeof metric.value === 'number') {
                        valueClass = metric.value < metric.threshold ? 'good' : 
                                   metric.value < metric.threshold * 2 ? 'warning' : 'error';
                    } else if (typeof metric.value === 'string') {
                        valueClass = metric.value.includes('Active') || metric.value.includes('Supported') ? 'good' : 'warning';
                    }
                    
                    metricDiv.innerHTML = `
                        <span>${metric.label}</span>
                        <span class="metric-value ${valueClass}">
                            ${typeof metric.value === 'number' ? metric.value.toFixed(1) : metric.value}${metric.unit}
                        </span>
                    `;
                    
                    metricsContainer.appendChild(metricDiv);
                });
                
                detailedResults.style.display = 'block';
            }
            
            stopTest() {
                this.isRunning = false;
                this.log('‚èπÔ∏è Test stopped by user', 'warning');
                document.getElementById('startTest').disabled = false;
                document.getElementById('stopTest').disabled = true;
            }
            
            clearResults() {
                document.getElementById('logContainer').innerHTML = '<div class="log-entry info">üîÑ Ready to start performance testing...</div>';
                document.getElementById('scoreDisplay').style.display = 'none';
                document.getElementById('detailedResults').style.display = 'none';
                
                // Reset all progress bars
                ['render', 'memory', 'serviceWorker', 'analytics'].forEach(type => {
                    this.updateProgress(type, 0);
                    this.updateStatus(type, '');
                });
                
                this.results = { rendering: {}, memory: {}, serviceWorker: {}, analytics: {}, score: 0 };
                this.log('üóëÔ∏è Results cleared', 'info');
            }
        }
        
        // Initialize the performance test when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.performanceTest = new ImprovedPerformanceTest();
        });
    </script>
</body>
</html>
