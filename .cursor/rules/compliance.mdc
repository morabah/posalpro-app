---
alwaysApply: true
---

# Context

You are working on PosalPro MVP2. Follow `@[docs/CORE_REQUIREMENTS.md]` for all implementations.

## üö® **CRITICAL: COMPLETE ANALYSIS BEFORE IMPLEMENTATION** {#complete-analysis-before-implementation}

**üîç MANDATORY: Analyze ALL Issues Before Any Implementation**

- **Step 1**: Identify ALL data mismatches, errors, and inconsistencies
- **Step 2**: Map the complete data flow from source to display
- **Step 3**: Identify ALL components, files, and layers affected
- **Step 4**: Plan comprehensive solution addressing ALL issues at once
- **Step 5**: Implement complete fix, not piece-by-piece solutions
- **NEVER**: Implement partial fixes or create test files to "verify" incomplete solutions

**üìã Analysis Checklist (MANDATORY)**

- [ ] Identify ALL data sources (API, database, cache, components)
- [ ] Map ALL data transformations and field mappings
- [ ] Identify ALL components reading/writing the data
- [ ] Check ALL related files (services, hooks, components, schemas)
- [ ] Verify ALL cache invalidation points
- [ ] Plan solution addressing ALL issues simultaneously

**‚ùå FORBIDDEN PRACTICES**

- Piece-by-piece fixes that create new problems
- Test files that don't actually fix real issues
- "Expected results" without actual implementation
- Partial solutions that require multiple iterations

## Must‚Äëread references

- Tier 1: `PROJECT_REFERENCE.md`, `WIREFRAME_INTEGRATION_GUIDE.md`, `DEVELOPMENT_STANDARDS.md` (see CORE_REQUIREMENTS.md ‚Üí Duplicate Prevention & Critical Reference Documents)
- Tier 2: `USER_STORY_TRACEABILITY_MATRIX.md`, `COMPONENT_STRUCTURE.md`, `DATA_MODEL.md`

## Pre‚ÄëImplementation Checklist

- `npm run type-check` ‚Üí 0 errors; `npm run audit:duplicates` (see CORE_REQUIREMENTS.md ‚Üí Pre‚ÄëImplementation Checklist)
- Review patterns in `src/lib/services`, `src/hooks`, `src/components`
- Use `npm run dev:smart` during development

## Implementation Standards

- **Bridge Pattern & API Bridges**: Use bridge templates from `templates/design-patterns/bridge/` for all new bridge implementations. Follow three-layer architecture: Components ‚Üí Management Bridge ‚Üí API Bridge ‚Üí API Routes. Replace all placeholders (**BRIDGE_NAME**, **ENTITY_TYPE**, **RESOURCE_NAME**, **USER_STORY**, **HYPOTHESIS**). (CORE_REQUIREMENTS.md ‚Üí Bridge Pattern & API Bridges)
- **React Query & Data Fetching**: server-side filtering/sorting/pagination; `staleTime: 30000`, `gcTime: 120000`; cursor-based "Load More"; use `useApiClient` only for simple one-time fetches. Request minimal `fields`, avoid relation hydration by default. (CORE_REQUIREMENTS.md ‚Üí Data Fetching & Performance; React Query Patterns)
- **Advanced Filtering**: debounced search (300ms), reset pagination on filter change, contextual empty states. (CORE_REQUIREMENTS.md ‚Üí Pagination & Search Patterns)
- **Error Handling**: use `ErrorHandlingService.processError()` and centralized hooks; user-friendly errors + retry. (CORE_REQUIREMENTS.md ‚Üí Error Handling & Type Safety)
- **Performance**: lazy-load icons/components, memoize callbacks/values, proper effect dependencies. (CORE_REQUIREMENTS.md ‚Üí Performance & Analytics; Development Build Stability)
- **Analytics & Traceability**: use optimized analytics; include `userStory`, `hypothesis`; track views, edits, navigation, errors, pagination. (CORE_REQUIREMENTS.md ‚Üí Analytics & Hypothesis Validation)
- **Security & RBAC**: guard sensitive API routes with `validateApiPermission` and scope; use centralized middleware. (CORE_REQUIREMENTS.md ‚Üí RBAC Authorization)
- **Accessibility**: WCAG 2.1 AA; 44px touch targets; full keyboard and screen reader support. (CORE_REQUIREMENTS.md ‚Üí Accessibility & UI Standards)
- **Architecture**: maintain SSR/CSR hydration consistency; use route-group layout provider stack; avoid unstable effect deps. (CORE_REQUIREMENTS.md ‚Üí Architecture & Providers)
- **UI Design System**: use components from `src/components/ui` and tokens from `src/design-system`. (CORE_REQUIREMENTS.md ‚Üí Design System Usage)
- **Documentation**: update `docs/IMPLEMENTATION_LOG.md`; add to `docs/LESSONS_LEARNED.md` when applicable; update `PROJECT_REFERENCE.md` for new routes/components. (CORE_REQUIREMENTS.md ‚Üí Documentation & Validation)
- **Quality Gates**: no TypeScript errors; follow lint rules; verify performance and accessibility. (CORE_REQUIREMENTS.md ‚Üí Quality Gates)

## Bridge Pattern Implementation (MANDATORY)

- **Template Usage**: Always use bridge templates from `templates/design-patterns/bridge/` for new bridge implementations
- **Template Workflow**:
  1. Copy `api-bridge.template.ts` ‚Üí `src/lib/bridges/EntityApiBridge.ts`
  2. Copy `management-bridge.template.tsx` ‚Üí `src/components/bridges/EntityManagementBridge.tsx`
  3. Copy `bridge-hook.template.ts` ‚Üí `src/hooks/useEntity.ts` (optional)
  4. Copy `bridge-component.template.tsx` ‚Üí `src/components/EntityList.tsx`
  5. Copy `bridge-page.template.tsx` ‚Üí `src/app/(dashboard)/entities/page.tsx`
- **Placeholder Replacement**: Replace all template placeholders:
  - `__BRIDGE_NAME__` ‚Üí EntityManagement
  - `__ENTITY_TYPE__` ‚Üí Entity
  - `__RESOURCE_NAME__` ‚Üí entities
  - `__USER_STORY__` ‚Üí US-X.X
  - `__HYPOTHESIS__` ‚Üí HX
- **Bridge Architecture**: Follow three-layer pattern: Components ‚Üí Management Bridge (React Context) ‚Üí API Bridge (Singleton) ‚Üí API Routes
- **Provider Requirements**: Ensure `GlobalStateProvider` wraps components using bridge hooks that call `useGlobalState()` or `useUIState()`
- **Template Compliance**: All bridges must follow template patterns for consistency and maintainability

## HTTP Client & Service Layer Standards (CRITICAL)

- **HTTP Client Pattern**: Use `http.method(url, data)` not `http.method(url, { body: JSON.stringify(data) })`
- **Response Handling**: Let HTTP client handle response envelopes automatically - don't manually unwrap `{ success: true, data: ... }` or `{ ok: true, data: ... }`
- **Service Layer Consistency**: All services must use same HTTP client pattern
- **API Response Compatibility**: HTTP client supports both `ok` and `success` properties for backward compatibility
- **Direct Type Parameters**: Use `http.get<UserList>()` not `http.get<{ success: boolean; data: UserList }>()`

## Store Data Access Patterns (CRITICAL)

- **Individual Selectors**: Use `useProposalStepData(stepNumber)` for each step, not array access
- **No Array Access**: Don't assume `stepData[1]` - understand selector return values
- **Store Implementation**: Read store implementation to understand data structure before using selectors
- **Stable Selectors**: Use individual selectors (primitives or tuple+shallow), not object literals
- **Client-Only Stores**: Ensure all store consumers are client-only and store isn't created per render

## Logging & Observability (Mandatory)

- **Use structured logger** from `@/lib/logger`: `logDebug`, `logInfo`, `logWarn`, `logError`. No `console.*` in product code. (CORE_REQUIREMENTS.md ‚Üí Logging & Observability)
- **Minimum coverage**:
  - Fetch/Query: `logDebug('Fetch start', { component, operation, keys })` ‚Üí `logInfo('Fetch success', { loadTime })` ‚Üí `logError('Fetch failed', { error })`
  - Mutation/Update: `logDebug('Update start', { payloadKeys })` ‚Üí `logInfo('Update success')` ‚Üí `logError('Update failed', { error })`
  - Critical UI/navigation: `logInfo('Action', { target, context })`
- **Metadata**: include `component`, `operation`, ids (e.g., `proposalId`, `customerId`), and traceability (`userStory`, `hypothesis`).
- **Pair with ErrorHandlingService**: log after `ErrorHandlingService.processError()` in catch blocks.
- **Env guidance**: verbose `debug` in dev; keep `info/warn/error` meaningful in prod.

## Error Prevention Framework

### **Common Anti-Patterns to Avoid**

1. ‚ùå **Creating new APIs when existing ones work**
2. ‚ùå **Composite hooks that create new objects on every render**
3. ‚ùå **Inconsistent field names across layers**
4. ‚ùå **Single response format support in HTTP clients**
5. ‚ùå **Long stale times for frequently updated data**
6. ‚ùå **Missing structured logging and error handling**
7. ‚ùå **Dynamic values in component IDs**
8. ‚ùå **Testing individual components without end-to-end flows**
9. ‚ùå **Manual response envelope handling in services**
10. ‚ùå **Array access on individual selector return values**

### **Always Follow These Patterns**

1. **Check existing implementations first** - Don't reinvent working solutions
2. **Use consistent naming across all layers** - Database schema is the source of truth
3. **Design stable state management from the start** - Individual selectors, functional updates
4. **Implement comprehensive logging from day one** - Structured, traceable, user-friendly
5. **Support multiple response formats** - Be format-agnostic in HTTP clients
6. **Use aggressive cache management** - Immediate updates, comprehensive invalidation
7. **Test with real data early and often** - Don't wait until the end
8. **Validate complete user flows** - Not just individual components
9. **Let HTTP client handle envelopes** - Don't manually unwrap response data
10. **Understand selector return values** - Check what selectors actually return

## Reference Implementation

- Use `/products` page and `ProductList` as the gold standard for data fetching, error handling, performance, structure, and logging.
- Use bridge templates from `templates/design-patterns/bridge/` as the gold standard for bridge pattern implementation.
- Use `src/services/productService.ts` as the gold standard for HTTP client usage patterns.
- Use `src/lib/store/proposalStore.ts` as the gold standard for store data access patterns.
- Use `src/features/*/keys.ts` as the gold standard for centralized query key management.
- Use `src/lib/api/response.ts` as the gold standard for API response formats including cursor pagination.

- Use `/products` page and `ProductList` as the gold standard for data fetching, error handling, performance, structure, and logging.
- Use bridge templates from `templates/design-patterns/bridge/` as the gold standard for bridge pattern implementation.

# Context

You are working on PosalPro MVP2. Follow `@[docs/CORE_REQUIREMENTS.md]` for all implementations.

## üö® **CRITICAL: COMPLETE ANALYSIS BEFORE IMPLEMENTATION** {#complete-analysis-before-implementation}

**üîç MANDATORY: Analyze ALL Issues Before Any Implementation**

- **Step 1**: Identify ALL data mismatches, errors, and inconsistencies
- **Step 2**: Map the complete data flow from source to display
- **Step 3**: Identify ALL components, files, and layers affected
- **Step 4**: Plan comprehensive solution addressing ALL issues at once
- **Step 5**: Implement complete fix, not piece-by-piece solutions
- **NEVER**: Implement partial fixes or create test files to "verify" incomplete solutions

**üìã Analysis Checklist (MANDATORY)**

- [ ] Identify ALL data sources (API, database, cache, components)
- [ ] Map ALL data transformations and field mappings
- [ ] Identify ALL components reading/writing the data
- [ ] Check ALL related files (services, hooks, components, schemas)
- [ ] Verify ALL cache invalidation points
- [ ] Plan solution addressing ALL issues simultaneously

**‚ùå FORBIDDEN PRACTICES**

- Piece-by-piece fixes that create new problems
- Test files that don't actually fix real issues
- "Expected results" without actual implementation
- Partial solutions that require multiple iterations

## Must‚Äëread references

- Tier 1: `PROJECT_REFERENCE.md`, `WIREFRAME_INTEGRATION_GUIDE.md`, `DEVELOPMENT_STANDARDS.md` (see CORE_REQUIREMENTS.md ‚Üí Duplicate Prevention & Critical Reference Documents)
- Tier 2: `USER_STORY_TRACEABILITY_MATRIX.md`, `COMPONENT_STRUCTURE.md`, `DATA_MODEL.md`

## Pre‚ÄëImplementation Checklist

- `npm run type-check` ‚Üí 0 errors; `npm run audit:duplicates` (see CORE_REQUIREMENTS.md ‚Üí Pre‚ÄëImplementation Checklist)
- Review patterns in `src/lib/services`, `src/hooks`, `src/components`
- Use `npm run dev:smart` during development

## Implementation Standards

- **Bridge Pattern & API Bridges**: Use bridge templates from `templates/design-patterns/bridge/` for all new bridge implementations. Follow three-layer architecture: Components ‚Üí Management Bridge ‚Üí API Bridge ‚Üí API Routes. Replace all placeholders (**BRIDGE_NAME**, **ENTITY_TYPE**, **RESOURCE_NAME**, **USER_STORY**, **HYPOTHESIS**). (CORE_REQUIREMENTS.md ‚Üí Bridge Pattern & API Bridges)
- **React Query & Data Fetching**: server-side filtering/sorting/pagination; `staleTime: 30000`, `gcTime: 120000`; cursor-based "Load More"; use `useApiClient` only for simple one-time fetches. Request minimal `fields`, avoid relation hydration by default. (CORE_REQUIREMENTS.md ‚Üí Data Fetching & Performance; React Query Patterns)
- **Advanced Filtering**: debounced search (300ms), reset pagination on filter change, contextual empty states. (CORE_REQUIREMENTS.md ‚Üí Pagination & Search Patterns)
- **Error Handling**: use `ErrorHandlingService.processError()` and centralized hooks; user-friendly errors + retry. (CORE_REQUIREMENTS.md ‚Üí Error Handling & Type Safety)
- **Performance**: lazy-load icons/components, memoize callbacks/values, proper effect dependencies. (CORE_REQUIREMENTS.md ‚Üí Performance & Analytics; Development Build Stability)
- **Analytics & Traceability**: use optimized analytics; include `userStory`, `hypothesis`; track views, edits, navigation, errors, pagination. (CORE_REQUIREMENTS.md ‚Üí Analytics & Hypothesis Validation)
- **Security & RBAC**: guard sensitive API routes with `validateApiPermission` and scope; use centralized middleware. (CORE_REQUIREMENTS.md ‚Üí RBAC Authorization)
- **Accessibility**: WCAG 2.1 AA; 44px touch targets; full keyboard and screen reader support. (CORE_REQUIREMENTS.md ‚Üí Accessibility & UI Standards)
- **Architecture**: maintain SSR/CSR hydration consistency; use route-group layout provider stack; avoid unstable effect deps. (CORE_REQUIREMENTS.md ‚Üí Architecture & Providers)
- **UI Design System**: use components from `src/components/ui` and tokens from `src/design-system`. (CORE_REQUIREMENTS.md ‚Üí Design System Usage)
- **Documentation**: update `docs/IMPLEMENTATION_LOG.md`; add to `docs/LESSONS_LEARNED.md` when applicable; update `PROJECT_REFERENCE.md` for new routes/components. (CORE_REQUIREMENTS.md ‚Üí Documentation & Validation)
- **Quality Gates**: no TypeScript errors; follow lint rules; verify performance and accessibility. (CORE_REQUIREMENTS.md ‚Üí Quality Gates)

## Bridge Pattern Implementation (MANDATORY)

- **Template Usage**: Always use bridge templates from `templates/design-patterns/bridge/` for new bridge implementations
- **Template Workflow**:
  1. Copy `api-bridge.template.ts` ‚Üí `src/lib/bridges/EntityApiBridge.ts`
  2. Copy `management-bridge.template.tsx` ‚Üí `src/components/bridges/EntityManagementBridge.tsx`
  3. Copy `bridge-hook.template.ts` ‚Üí `src/hooks/useEntity.ts` (optional)
  4. Copy `bridge-component.template.tsx` ‚Üí `src/components/EntityList.tsx`
  5. Copy `bridge-page.template.tsx` ‚Üí `src/app/(dashboard)/entities/page.tsx`
- **Placeholder Replacement**: Replace all template placeholders:
  - `__BRIDGE_NAME__` ‚Üí EntityManagement
  - `__ENTITY_TYPE__` ‚Üí Entity
  - `__RESOURCE_NAME__` ‚Üí entities
  - `__USER_STORY__` ‚Üí US-X.X
  - `__HYPOTHESIS__` ‚Üí HX
- **Bridge Architecture**: Follow three-layer pattern: Components ‚Üí Management Bridge (React Context) ‚Üí API Bridge (Singleton) ‚Üí API Routes
- **Provider Requirements**: Ensure `GlobalStateProvider` wraps components using bridge hooks that call `useGlobalState()` or `useUIState()`
- **Template Compliance**: All bridges must follow template patterns for consistency and maintainability

## HTTP Client & Service Layer Standards (CRITICAL)

- **HTTP Client Pattern**: Use `http.method(url, data)` not `http.method(url, { body: JSON.stringify(data) })`
- **Response Handling**: Let HTTP client handle response envelopes automatically - don't manually unwrap `{ success: true, data: ... }` or `{ ok: true, data: ... }`
- **Service Layer Consistency**: All services must use same HTTP client pattern
- **API Response Compatibility**: HTTP client supports both `ok` and `success` properties for backward compatibility
- **Direct Type Parameters**: Use `http.get<UserList>()` not `http.get<{ success: boolean; data: UserList }>()`

## Store Data Access Patterns (CRITICAL)

- **Individual Selectors**: Use `useProposalStepData(stepNumber)` for each step, not array access
- **No Array Access**: Don't assume `stepData[1]` - understand selector return values
- **Store Implementation**: Read store implementation to understand data structure before using selectors
- **Stable Selectors**: Use individual selectors (primitives or tuple+shallow), not object literals
- **Client-Only Stores**: Ensure all store consumers are client-only and store isn't created per render

## Logging & Observability (Mandatory)

- **Use structured logger** from `@/lib/logger`: `logDebug`, `logInfo`, `logWarn`, `logError`. No `console.*` in product code. (CORE_REQUIREMENTS.md ‚Üí Logging & Observability)
- **Minimum coverage**:
  - Fetch/Query: `logDebug('Fetch start', { component, operation, keys })` ‚Üí `logInfo('Fetch success', { loadTime })` ‚Üí `logError('Fetch failed', { error })`
  - Mutation/Update: `logDebug('Update start', { payloadKeys })` ‚Üí `logInfo('Update success')` ‚Üí `logError('Update failed', { error })`
  - Critical UI/navigation: `logInfo('Action', { target, context })`
- **Metadata**: include `component`, `operation`, ids (e.g., `proposalId`, `customerId`), and traceability (`userStory`, `hypothesis`).
- **Pair with ErrorHandlingService**: log after `ErrorHandlingService.processError()` in catch blocks.
- **Env guidance**: verbose `debug` in dev; keep `info/warn/error` meaningful in prod.

## Error Prevention Framework

### **Common Anti-Patterns to Avoid**

1. ‚ùå **Creating new APIs when existing ones work**
2. ‚ùå **Composite hooks that create new objects on every render**
3. ‚ùå **Inconsistent field names across layers**
4. ‚ùå **Single response format support in HTTP clients**
5. ‚ùå **Long stale times for frequently updated data**
6. ‚ùå **Missing structured logging and error handling**
7. ‚ùå **Dynamic values in component IDs**
8. ‚ùå **Testing individual components without end-to-end flows**
9. ‚ùå **Manual response envelope handling in services**
10. ‚ùå **Array access on individual selector return values**

### **Always Follow These Patterns**

1. **Check existing implementations first** - Don't reinvent working solutions
2. **Use consistent naming across all layers** - Database schema is the source of truth
3. **Design stable state management from the start** - Individual selectors, functional updates
4. **Implement comprehensive logging from day one** - Structured, traceable, user-friendly
5. **Support multiple response formats** - Be format-agnostic in HTTP clients
6. **Use aggressive cache management** - Immediate updates, comprehensive invalidation
7. **Test with real data early and often** - Don't wait until the end
8. **Validate complete user flows** - Not just individual components
9. **Let HTTP client handle envelopes** - Don't manually unwrap response data
10. **Understand selector return values** - Check what selectors actually return

## Reference Implementation

- Use `/products` page and `ProductList` as the gold standard for data fetching, error handling, performance, structure, and logging.
- Use bridge templates from `templates/design-patterns/bridge/` as the gold standard for bridge pattern implementation.
- Use `src/services/productService.ts` as the gold standard for HTTP client usage patterns.
- Use `src/lib/store/proposalStore.ts` as the gold standard for store data access patterns.
- Use `src/features/*/keys.ts` as the gold standard for centralized query key management.
- Use `src/lib/api/response.ts` as the gold standard for API response formats including cursor pagination.

- Use `/products` page and `ProductList` as the gold standard for data fetching, error handling, performance, structure, and logging.
- Use bridge templates from `templates/design-patterns/bridge/` as the gold standard for bridge pattern implementation.
